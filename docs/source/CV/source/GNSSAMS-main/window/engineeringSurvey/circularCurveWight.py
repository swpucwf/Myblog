# -*- coding: utf-8 -*-

# Form implementation generated from reading ui file 'circularCurveWight.ui'
#
# Created by: PyQt5 UI code generator 5.15.0
#
# WARNING: Any manual changes made to this file will be lost when pyuic5 is
# run again.  Do not edit this file unless you know what you are doing.


from PyQt5 import QtCore, QtGui, QtWidgets
import numpy as np

from database.database import Database
from measureTool.angleConversion import Angle


class Ui_Form(QtCore.QObject):
    infoEmit = QtCore.pyqtSignal(str, str)

    def setupUi(self, Form):
        Form.setObjectName("Form")
        Form.resize(1198, 765)
        icon = QtGui.QIcon()
        icon.addPixmap(QtGui.QPixmap("./source/icon/download.png"), QtGui.QIcon.Normal, QtGui.QIcon.Off)
        Form.setWindowIcon(icon)
        self.horizontalLayout = QtWidgets.QHBoxLayout(Form)
        self.horizontalLayout.setObjectName("horizontalLayout")
        self.verticalLayout_4 = QtWidgets.QVBoxLayout()
        self.verticalLayout_4.setObjectName("verticalLayout_4")
        spacerItem = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_4.addItem(spacerItem)
        self.groupBox = QtWidgets.QGroupBox(Form)
        self.groupBox.setObjectName("groupBox")
        self.verticalLayout_2 = QtWidgets.QVBoxLayout(self.groupBox)
        self.verticalLayout_2.setObjectName("verticalLayout_2")
        self.button_mainMileage = QtWidgets.QPushButton(self.groupBox)
        self.button_mainMileage.setObjectName("button_mainMileage")
        self.verticalLayout_2.addWidget(self.button_mainMileage)
        self.button_pointStation = QtWidgets.QPushButton(self.groupBox)
        self.button_pointStation.setObjectName("button_pointStation")
        self.verticalLayout_2.addWidget(self.button_pointStation)
        self.verticalLayout_4.addWidget(self.groupBox)
        self.groupBox_2 = QtWidgets.QGroupBox(Form)
        self.groupBox_2.setObjectName("groupBox_2")
        self.verticalLayout_3 = QtWidgets.QVBoxLayout(self.groupBox_2)
        self.verticalLayout_3.setObjectName("verticalLayout_3")
        self.button_easementMainMileage = QtWidgets.QPushButton(self.groupBox_2)
        self.button_easementMainMileage.setObjectName("button_easementMainMileage")
        self.verticalLayout_3.addWidget(self.button_easementMainMileage)
        self.button_easementPointStation = QtWidgets.QPushButton(self.groupBox_2)
        self.button_easementPointStation.setObjectName("button_easementPointStation")
        self.verticalLayout_3.addWidget(self.button_easementPointStation)
        self.label_2 = QtWidgets.QLabel(self.groupBox_2)
        self.label_2.setText("")
        self.label_2.setPixmap(QtGui.QPixmap("./source/icon/designer-tools.png"))
        self.label_2.setAlignment(QtCore.Qt.AlignCenter)
        self.label_2.setObjectName("label_2")
        self.verticalLayout_3.addWidget(self.label_2)
        spacerItem1 = QtWidgets.QSpacerItem(20, 40, QtWidgets.QSizePolicy.Minimum, QtWidgets.QSizePolicy.Expanding)
        self.verticalLayout_3.addItem(spacerItem1)
        self.verticalLayout_4.addWidget(self.groupBox_2)
        self.horizontalLayout.addLayout(self.verticalLayout_4)
        self.groupBox_3 = QtWidgets.QGroupBox(Form)
        self.groupBox_3.setObjectName("groupBox_3")
        self.verticalLayout = QtWidgets.QVBoxLayout(self.groupBox_3)
        self.verticalLayout.setObjectName("verticalLayout")
        self.tableWidget = QtWidgets.QTableWidget(self.groupBox_3)
        self.tableWidget.setObjectName("tableWidget")
        self.tableWidget.setColumnCount(11)
        self.tableWidget.setRowCount(1)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setVerticalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(0, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(1, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(2, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(3, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(4, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(5, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(6, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(7, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(8, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(9, item)
        item = QtWidgets.QTableWidgetItem()
        self.tableWidget.setHorizontalHeaderItem(10, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 0, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 1, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 2, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 3, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 4, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 5, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 6, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 7, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 8, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 9, item)
        item = QtWidgets.QTableWidgetItem()
        item.setTextAlignment(QtCore.Qt.AlignCenter)
        self.tableWidget.setItem(0, 10, item)
        self.verticalLayout.addWidget(self.tableWidget)
        self.commandLinkButton = QtWidgets.QCommandLinkButton(self.groupBox_3)
        self.commandLinkButton.setObjectName("commandLinkButton")
        self.verticalLayout.addWidget(self.commandLinkButton)
        self.line = QtWidgets.QFrame(self.groupBox_3)
        self.line.setFrameShape(QtWidgets.QFrame.HLine)
        self.line.setFrameShadow(QtWidgets.QFrame.Sunken)
        self.line.setObjectName("line")
        self.verticalLayout.addWidget(self.line)
        self.horizontalLayout_2 = QtWidgets.QHBoxLayout()
        self.horizontalLayout_2.setObjectName("horizontalLayout_2")
        self.label = QtWidgets.QLabel(self.groupBox_3)
        sizePolicy = QtWidgets.QSizePolicy(QtWidgets.QSizePolicy.Preferred, QtWidgets.QSizePolicy.Preferred)
        sizePolicy.setHorizontalStretch(0)
        sizePolicy.setVerticalStretch(0)
        sizePolicy.setHeightForWidth(self.label.sizePolicy().hasHeightForWidth())
        self.label.setSizePolicy(sizePolicy)
        self.label.setText("")
        self.label.setPixmap(QtGui.QPixmap("./source/icon/ric.png"))
        self.label.setAlignment(QtCore.Qt.AlignCenter)
        self.label.setObjectName("label")
        self.horizontalLayout_2.addWidget(self.label)
        self.textEdit = QtWidgets.QTextEdit(self.groupBox_3)
        self.textEdit.setObjectName("textEdit")
        self.horizontalLayout_2.addWidget(self.textEdit)
        self.verticalLayout.addLayout(self.horizontalLayout_2)
        self.horizontalLayout.addWidget(self.groupBox_3)

        self.retranslateUi(Form)
        self.button_mainMileage.clicked.connect(self.actionMainMileage)
        self.button_pointStation.clicked.connect(self.action_singleCircularCurveMiddlePilePointCoor)
        self.button_easementMainMileage.clicked.connect(self.action_relief_circularCurve_principalPointMileage)
        self.button_easementPointStation.clicked.connect(self.action_relief_circularCurve_middlePilePointCoor)
        QtCore.QMetaObject.connectSlotsByName(Form)

    def retranslateUi(self, Form):
        _translate = QtCore.QCoreApplication.translate
        Form.setWindowTitle(_translate("Form", "Form"))
        self.groupBox.setTitle(_translate("Form", "圆曲线计算"))
        self.button_mainMileage.setText(_translate("Form", "计算主点里程"))
        self.button_pointStation.setText(_translate("Form", "解算曲线中桩点坐标"))
        self.groupBox_2.setTitle(_translate("Form", "带缓和曲线的圆曲线计算"))
        self.button_easementMainMileage.setText(_translate("Form", "计算主点里程"))
        self.button_easementPointStation.setText(_translate("Form", "解算曲线中桩点坐标"))
        self.groupBox_3.setTitle(_translate("Form", "待解算数据"))
        item = self.tableWidget.verticalHeaderItem(0)
        item.setText(_translate("Form", "1"))
        item = self.tableWidget.horizontalHeaderItem(0)
        item.setText(_translate("Form", "ID"))
        item = self.tableWidget.horizontalHeaderItem(1)
        item.setText(_translate("Form", "圆曲线半径/m"))
        item = self.tableWidget.horizontalHeaderItem(2)
        item.setText(_translate("Form", "路线转向角/(°)"))
        item = self.tableWidget.horizontalHeaderItem(3)
        item.setText(_translate("Form", "路线转向角类型/(R/L)"))
        item = self.tableWidget.horizontalHeaderItem(4)
        item.setText(_translate("Form", "里程桩号"))
        item = self.tableWidget.horizontalHeaderItem(5)
        item.setText(_translate("Form", "交点JD里程/m"))
        item = self.tableWidget.horizontalHeaderItem(6)
        item.setText(_translate("Form", "*缓和曲线长/m"))
        item = self.tableWidget.horizontalHeaderItem(7)
        item.setText(_translate("Form", "*交点JD的X坐标/m"))
        item = self.tableWidget.horizontalHeaderItem(8)
        item.setText(_translate("Form", "*交点JD的Y坐标/m"))
        item = self.tableWidget.horizontalHeaderItem(9)
        item.setText(_translate("Form", "*待求中桩点里程/m"))
        item = self.tableWidget.horizontalHeaderItem(10)
        item.setText(_translate("Form", "入(出)线坐标方位角/°"))
        __sortingEnabled = self.tableWidget.isSortingEnabled()
        self.tableWidget.setSortingEnabled(False)
        item = self.tableWidget.item(0, 0)
        item.setText(_translate("Form", "示例编号G01"))
        item = self.tableWidget.item(0, 1)
        item.setText(_translate("Form", "203"))
        item = self.tableWidget.item(0, 2)
        item.setText(_translate("Form", "20.36"))
        item = self.tableWidget.item(0, 3)
        item.setText(_translate("Form", "R"))
        item = self.tableWidget.item(0, 4)
        item.setText(_translate("Form", "DK"))
        item = self.tableWidget.item(0, 5)
        item.setText(_translate("Form", "258.36"))
        self.tableWidget.setSortingEnabled(__sortingEnabled)
        self.commandLinkButton.setText(_translate("Form", "1.右键单击上方表格区域可以手动添加数据； 2.可以导入整理后的.rc格式的文本文件，格式参照说明"))
        self.textEdit.setHtml(_translate("Form",
                                         "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.0//EN\" \"http://www.w3.org/TR/REC-html40/strict.dtd\">\n"
                                         "<html><head><meta name=\"qrichtext\" content=\"1\" /><style type=\"text/css\">\n"
                                         "p, li { white-space: pre-wrap; }\n"
                                         "</style></head><body style=\" font-family:\'SimSun\'; font-size:9pt; font-weight:400; font-style:normal;\">\n"
                                         "<p style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">说明：</p>\n"
                                         "<p style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">1.如果只解算主点里程，数据只需要输入到交点JD里程即可；</p>\n"
                                         "<p style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">2.所有输入的角度的单位均取: 度(°)；</p>\n"
                                         "<p style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">3.坐标方位角取法：</p>\n"
                                         "<p style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">  1）待求点在ZY-QZ：ZYJD；</p>\n"
                                         "<p style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">  2）待求点在QZ-YZ：JDYZ；</p>\n"
                                         "<p style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\">  3）同理，对于带有缓和曲线的坐标方位角取法：ZHJD or JDHZ。</p>\n"
                                         "<p style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><br /></p>\n"
                                         "<p style=\" margin-top:12px; margin-bottom:12px; margin-left:0px; margin-right:0px; -qt-block-indent:0; text-indent:0px;\"><span style=\" font-family:\'Source Code Pro\'; font-size:10.5pt; font-style:italic; color:#546e7a;\">=================</span></p></body></html>"))

    def fileSetData(self):
        # 从文件导入数据
        dataList = []
        with open(Database.circulaiCurveCRFilePath,"r") as f:
            for line in f:
                lineList = line.strip().split()
                if len(lineList) != 11:
                    lineList = line.strip().split(",")
                if len(lineList) != 11:
                    lineList = line.strip().split("，")
                # 开始执行插入操作
                if len(lineList) == 11:
                    dataList.append(lineList)
                else:
                    self.sendTopInfo("W", "输入的文件数据格式有误！请按照RC文件格式\n编辑数据，格式与界面内表格相同！注意：数据为空时用0代替")
                    break
        f.close()
        if len(dataList) > 0:
            # 设置表格列数
            self.tableWidget.setRowCount(len(dataList))
            for i in range(len(dataList)):
                for k in range(len(dataList[0])):
                    self.tableWidget.setItem(i,k,QtWidgets.QTableWidgetItem())
                    self.tableWidget.item(i, k).setText(dataList[i][k])
                    self.tableWidget.item(i, k).setTextAlignment(QtCore.Qt.AlignCenter)

    def actionReport(self):
        return self.textEdit.toPlainText()

    def actionMainMileage(self):
        """
        曲线主点里程
        :return:
        """
        try:
            # 从表格读取数据
            self.textEdit.append("\n  == 单圆曲线主点里程 ==")
            for i in range(self.tableWidget.rowCount()):
                lineList = []
                for k in range(6):
                    lineList.append(self.tableWidget.item(i, k).text().strip())
                self.textEdit.append("--当前解算ID：{}".format(lineList[0]))

                self.singleCircularCurve_principalPointMileage(float(lineList[1]), np.deg2rad(float(lineList[2])),
                                                               lineList[4], float(lineList[5]))
                self.textEdit.append("-------")
            self.textEdit.append("=========||========")
        except Exception as e:
            self.sendTopInfo("E", "异常错误！可能原因：\n 1.待解算数据未填充或是填写错误；"
                                  "\n2.填写数据为汉字字符等非数据类型；"
                                  "\n3.详细信息：" + e.__str__())

    def action_singleCircularCurveMiddlePilePointCoor(self):
        """
        曲线中桩点坐标
        :return:
        """
        try:
            self.textEdit.append("\n  == 单圆曲线中桩点坐标计算 ==")
            for i in range(self.tableWidget.rowCount()):
                lineList = []
                for k in range(self.tableWidget.columnCount()):
                    lineList.append(self.tableWidget.item(i, k).text().strip())
                self.textEdit.append("--当前解算ID：{}".format(lineList[0]))
                self.singleCircularCurve_middlePilePointCoor(float(lineList[1]), np.deg2rad(float(lineList[2])),
                                                             lineList[3], float(lineList[5]),
                                                             float(lineList[7]), float(lineList[8]),
                                                             float(lineList[9]), np.deg2rad(float(lineList[10])))
                self.textEdit.append("-------")
            self.textEdit.append("=========||========")
        except Exception as e:
            self.sendTopInfo("E", "异常错误！可能原因：\n 1.待解算数据未填充或是填写错误；"
                                  "\n2.填写数据为汉字字符等非数据类型；"
                                  "\n3.详细信息：" + e.__str__())

    def action_relief_circularCurve_principalPointMileage(self):
        """
        带缓和曲线的主点里程
        :return:
        """
        try:
            # 从表格读取数据
            self.textEdit.append("\n  == 带有缓和曲线的圆曲线主点里程 ==")
            for i in range(self.tableWidget.rowCount()):
                lineList = []
                for k in range(7):
                    lineList.append(self.tableWidget.item(i, k).text().strip())
                self.textEdit.append("--当前解算ID：{}".format(lineList[0]))

                self.relief_circularCurve_principalPointMileage(float(lineList[1]),
                                                                np.deg2rad(float(lineList[2])),
                                                                lineList[4],
                                                                float(lineList[5]), float(lineList[6]))
                self.textEdit.append("-------")
            self.textEdit.append("=========||========")
        except Exception as e:
            self.sendTopInfo("E", "异常错误！可能原因：\n 1.待解算数据未填充或是填写错误；"
                                  "\n2.填写数据为汉字字符等非数据类型；"
                                  "\n3.详细信息：" + e.__str__())

    def action_relief_circularCurve_middlePilePointCoor(self):
        """
        带缓和曲线的中桩点坐标
        :return:
        """
        try:
            self.textEdit.append("\n  == 带有缓和曲线的圆曲线中桩点坐标计算 ==")
            for i in range(self.tableWidget.rowCount()):
                lineList = []
                for k in range(self.tableWidget.columnCount()):
                    lineList.append(self.tableWidget.item(i, k).text().strip())
                self.textEdit.append("--当前解算ID：{}".format(lineList[0]))
                self.relief_circularCurve_middlePilePointCoor(float(lineList[1]), np.deg2rad(float(lineList[2])),
                                                              lineList[3], lineList[4], float(lineList[5]),
                                                              float(lineList[6]),
                                                              float(lineList[7]), float(lineList[8]),
                                                              float(lineList[9]), np.deg2rad(float(lineList[10])))
                self.textEdit.append("-------")
            self.textEdit.append("=========||========")
        except Exception as e:
            self.sendTopInfo("E", "异常错误！可能原因：\n 1.待解算数据未填充或是填写错误；"
                                  "\n2.填写数据为汉字字符等非数据类型；"
                                  "\n3.详细信息：" + e.__str__())

    def sendTopInfo(self, type, strInfo):
        self.infoEmit.emit(type, strInfo)

    def singleCircularCurve_principalPointMileage(self, circularR, steerAngle_alpha, KJD_type, K_JD):
        """
        圆曲线主点里程计算
        :param circularR: 圆曲线半径R:m
        :param steerAngle_alpha: 线路转向角（弧度）
        :param K_JD: 交点JD里程：m
        :return:
        """
        # 圆曲线切线长
        T = circularR * np.tan(steerAngle_alpha / 2)
        # 曲线长
        L = circularR * steerAngle_alpha
        # 曲线外矢距
        # E = circularR * (1 / math.cos(steerAngle_alpha / 2) - 1)
        # 切曲差
        q = 2 * T - L

        # 计算主点里程
        K_ZY = K_JD - T
        K_QZ = K_ZY + L / 2
        K_YZ = K_ZY + L

        # 检核
        JH1 = K_QZ + q / 2
        JH2 = K_ZY + T
        self.textEdit.append("检核数据：KJD={}, JH1={}, JH2={}".format(K_JD, JH1, JH2))

        if K_JD == JH2 and K_JD == JH1:
            self.textEdit.append("检核正确！")
            self.textEdit.append(
                " 主点里程有：\n 1)直圆点ZY:{}+{} m；2）曲中点QZ：{}+{} m；3）圆直点YZ：{}+{} m。".format(KJD_type, K_ZY, KJD_type, K_QZ,
                                                                                    KJD_type, K_YZ))
        else:
            if JH1 - K_JD < 1.0E6 and JH2 - K_JD < 1.0E6:
                self.textEdit.append("基本检核正确！")
                self.textEdit.append(" 主点里程有：\n 1)直圆点ZY:{}+{} m；2）曲中点QZ：{}+{} m；3）圆直点YZ：{}+{} m。".format(KJD_type,K_ZY,KJD_type, K_QZ,KJD_type, K_YZ))
            else:
                self.sendTopInfo("T", "计算错误，再看看输入数据？我已经保证算法无误了")

    def singleCircularCurve_middlePilePointCoor(self, circularR, steerAngle_alpha, steerAngleType, K_JD, JD_CoorX,
                                                JD_CoorY,
                                                K_middlePilePoint, alpha_ZYJDorJDYZ):
        """
        计算已知里程中桩点的坐标
        <p> 前提：待求中桩点所在圆曲线的R，路线转向角alpha，交点JD里程，待求中桩点里程
        :param circularR: 中桩点所在圆曲线的半径：m
        :param steerAngle_alpha: 线路转向角（弧度）
        :param steerAngleType: 线路转向角方向：R-右折角，L-左折角
        :param K_JD: 交点JD里程：m
        :param JD_CoorX: 交点JD的X坐标
        :param JD_CoorY: 交点JD的Y坐标
        :param K_middlePilePoint: 待求中桩点里程：m
        :param alpha_ZYJDorJDYZ: 坐标方位角(弧度）：1.待求点在ZY-QZ：ZYJD；2.待求点在QZ-YZ：JDYZ
        :return:
        """
        # 圆曲线切线长
        T = circularR * np.tan(steerAngle_alpha / 2)
        # 曲线长
        L = circularR * steerAngle_alpha
        # 曲线外矢距
        # E = circularR * (1 / math.cos(steerAngle_alpha / 2) - 1)
        q = 2 * T - L

        # 计算主点里程
        K_ZY = K_JD - T
        K_QZ = K_ZY + L / 2
        K_YZ = K_ZY + L

        # 检核
        JH1 = K_QZ + q / 2
        JH2 = K_ZY + T
        self.textEdit.append("检核数据：KJD={}, JH1={}, JH2={}".format(K_JD, JH1, JH2))

        if (K_JD == JH2 and K_JD == JH1) or (JH1 - K_JD < 1.0E6 and JH2 - K_JD < 1.0E6):
            self.textEdit.append("主点里程计算结果检核正确！执行下一步计算")
            # 根据QZ点判断中桩点位于圆曲线的区域
            if K_middlePilePoint < K_QZ and K_middlePilePoint > K_ZY:
                self.textEdit.append("-中桩点位于圆曲线区域：前半段")
                # 前半段
                distanceDifference = K_middlePilePoint - K_ZY
                # 计算独立坐标系下坐标
                seta = distanceDifference / circularR
                x = circularR * np.sin(seta)
                y = circularR * (1 - np.cos(seta))
                if steerAngleType == "L":
                    y = -y
                # 计算 ZY/YZ 的坐标，需要知道ZY-JD/JD-YZ的坐标方位角
                X_ZY = JD_CoorX - T * np.cos(alpha_ZYJDorJDYZ)
                Y_ZY = JD_CoorY - T * np.sin(alpha_ZYJDorJDYZ)
                # 统一坐标系下的坐标
                X_middlePilePoint = X_ZY + x * np.cos(alpha_ZYJDorJDYZ) - y * np.sin(alpha_ZYJDorJDYZ)
                Y_middlePilePoint = Y_ZY + x * np.sin(alpha_ZYJDorJDYZ) + y * np.cos(alpha_ZYJDorJDYZ)

            elif K_middlePilePoint < K_YZ and K_middlePilePoint > K_QZ:
                self.textEdit.append("-中桩点位于圆曲线区域：后半段")
                # 后半段
                distanceDifference = K_ZY - K_middlePilePoint
                # 计算独立坐标系下坐标
                seta = distanceDifference / circularR
                x = circularR * np.sin(seta)
                y = circularR * (1 - np.cos(seta))
                if steerAngleType == "L":
                    y = -y
                # 计算 ZY/YZ 的坐标，需要知道ZY-JD/JD-YZ的坐标方位角
                X_YZ = JD_CoorX - T * np.cos(alpha_ZYJDorJDYZ)
                Y_YZ = JD_CoorY - T * np.sin(alpha_ZYJDorJDYZ)
                # 统一坐标系下的坐标
                X_middlePilePoint = X_YZ + x * np.cos(alpha_ZYJDorJDYZ) + y * np.sin(alpha_ZYJDorJDYZ)
                Y_middlePilePoint = Y_YZ + x * np.sin(alpha_ZYJDorJDYZ) - y * np.cos(alpha_ZYJDorJDYZ)
            else:
                self.sendTopInfo("W", "中桩点不在圆曲线上，错误！")
                return None
            self.textEdit.append("计算完成！坐标为: X:{}m,Y:{}m".format(X_middlePilePoint, Y_middlePilePoint))

        else:
            self.sendTopInfo("E", "主点里程计算错误,检核失败")

    def relief_circularCurve_principalPointMileage(self, circularR, steerAngle_alpha, KJD_type, K_JD, Ls):
        """
        带有缓和曲线的圆曲线主点里程计算
        :param circularR: 圆曲线半径R:m
        :param steerAngle_alpha: 线路转向角（弧度）
        :param Ls: 缓和曲线长度：m
        :param K_JD: 交点JD里程：m
        :return:
        """
        # 切垂距
        m = Ls / 2 - Ls * Ls * Ls / (240 * circularR * circularR)
        # 圆曲线内移值
        P = Ls * Ls / (24 * circularR)
        # 缓和曲线的切线角
        bata_0 = Ls * 180 / (2 * circularR * np.pi)  # 度
        DMS = Angle(bata_0).degreeToDMS()
        self.textEdit.append("缓和曲线的切线角DMS:{}°{}′{}″".format(DMS[0], DMS[1], DMS[2]))
        # 切线长
        TH = (circularR + P) * np.tan(steerAngle_alpha / 2) + m
        # 曲线长
        LH = np.pi * circularR * (steerAngle_alpha * 180 / np.pi - 2 * bata_0) / 180 + 2 * Ls
        LT = LH - 2 * Ls
        # 外矢距
        EH = (circularR + P) * (1 / np.cos(steerAngle_alpha / 2)) - circularR
        # 切曲差
        q = 2 * TH - LH

        # 主点里程
        K_ZH = K_JD - TH
        K_HY = K_ZH + Ls

        K_QZ = K_ZH + LH / 2
        K_YH = K_HY + LT
        K_HZ = K_YH + Ls

        # 检核
        self.textEdit.append("检核： K_QZ + 1 / 2 * q:{},K_JD:{}".format(K_QZ + 1 / 2 * q, K_JD))
        if K_JD - (K_QZ + 1 / 2 * q) < 1E-5 or (K_QZ + 1 / 2 * q) == K_JD:
            self.textEdit.append("曲线综合要素计算检核正确")
            data = [m, P, bata_0, TH, K_ZH, K_HY, K_QZ, K_YH, K_HZ]
            name = ["切垂距m/m", "圆曲线内移值P/m", "缓和曲线的切线角bata_0/度", "切线长TH/m", "K_ZH", "K_HY", "K_QZ", "K_YH", "K_HZ"]
            self.textEdit.append("解算各项结果如下：")
            for i in range(len(name)):
                if i < 4:
                    self.textEdit.append(" ({}){}:{}".format(i, name[i], data[i]))
                else:
                    self.textEdit.append(" ({}){}:{}+{}m".format(i, name[i], KJD_type, data[i]))
            return {"code": 1,
                    "result": [m, P, bata_0, TH, K_ZH, K_HY, K_QZ, K_YH, K_HZ]}
        else:
            self.textEdit("曲线综合要素计算检核错误!")
            return {"code": 0}

    def relief_circularCurve_middlePilePointCoor(self, circularR, steerAngle_alpha, steerAngleType, KJD_type, K_JD, Ls,
                                                 JD_CoorX,
                                                 JD_CoorY,
                                                 K_middlePilePoint, alpha_ZHYJDorJDHZ):
        """
        计算已知里程中桩点的坐标
        <p> 前提：待求中桩点所在圆曲线的R，路线转向角alpha，交点JD里程，待求中桩点里程
        :param circularR: 中桩点所在圆曲线的半径：m
        :param steerAngle_alpha: 线路转向角（弧度）
        :param steerAngleType: 线路转向角方向：R-右折角，L-左折角
        :param Ls: 缓和曲线长：m
        :param K_JD: 交点JD里程：m
        :param JD_CoorX: 交点JD的X坐标
        :param JD_CoorY: 交点JD的Y坐标
        :param K_middlePilePoint: 待求中桩点里程：m
        :param alpha_ZHYJDorJDHZ: 坐标方位角：弧度
        :return:
        """
        # 获取曲线主点参数
        principalPointDict = self.relief_circularCurve_principalPointMileage(circularR, steerAngle_alpha, KJD_type,
                                                                             K_JD, Ls)
        if principalPointDict["code"] == 1:
            # 检核正确
            m = principalPointDict["result"][0]
            P = principalPointDict["result"][1]
            # bata =  principalPointDict["result"][2]
            T = principalPointDict["result"][3]
            K_ZH = principalPointDict["result"][4]
            K_HY = principalPointDict["result"][5]
            # K_QZ = principalPointDict["result"][6]
            K_YH = principalPointDict["result"][7]
            K_HZ = principalPointDict["result"][8]

            # 计算线路坐标
            X_ZHorHZ = JD_CoorX - T * np.cos(alpha_ZHYJDorJDHZ)
            Y_ZHorHZ = JD_CoorY - T * np.sin(alpha_ZHYJDorJDHZ)

            # 判断待求中桩点的位置
            if K_middlePilePoint > K_ZH and K_middlePilePoint < K_HY:
                self.textEdit.append("中桩点在第一段缓和曲线上")
                # 在第一段缓曲线上
                L_I = K_middlePilePoint - K_ZH
                x_I = L_I - L_I ** 5 / (40 * circularR * circularR * Ls * Ls)
                y_I = L_I * L_I * L_I / (6 * circularR * Ls)
                if steerAngleType == "L":
                    y_I = - y_I
                X_middlePilePoint = X_ZHorHZ + x_I * np.cos(alpha_ZHYJDorJDHZ) - y_I * np.sin(alpha_ZHYJDorJDHZ)
                Y_middlePilePoint = Y_ZHorHZ + x_I * np.sin(alpha_ZHYJDorJDHZ) + y_I * np.cos(alpha_ZHYJDorJDHZ)


            elif K_middlePilePoint > K_HY and K_middlePilePoint < K_YH:
                # 在圆曲线区域,归并到第一个独立坐标系进行计算
                self.textEdit.append("在圆曲线区域,归并到第一个独立坐标系进行计算")
                L_circular = K_middlePilePoint - K_ZH
                seta = (L_circular - 0.5 * Ls) / circularR
                x_circular = m + circularR * np.sin(seta)
                y_circular = P + circularR * (1 - np.cos(seta))
                if steerAngleType == "L":
                    y_circular = - y_circular
                X_middlePilePoint = X_ZHorHZ + x_circular * np.cos(alpha_ZHYJDorJDHZ) - y_circular * np.sin(
                    alpha_ZHYJDorJDHZ)
                Y_middlePilePoint = Y_ZHorHZ + x_circular * np.sin(alpha_ZHYJDorJDHZ) + y_circular * np.cos(
                    alpha_ZHYJDorJDHZ)


            elif K_middlePilePoint > K_YH and K_middlePilePoint < K_HZ:
                # 在第二段缓曲线上
                self.textEdit.append("中桩点在第二段缓曲线上")
                L_II = K_HZ - K_middlePilePoint
                x_II = L_II - L_II ** 5 / (40 * circularR * circularR * Ls * Ls)
                y_II = L_II * L_II * L_II / (6 * circularR * Ls)
                if steerAngleType == "L":
                    y_II = - y_II
                X_middlePilePoint = X_ZHorHZ + x_II * np.cos(alpha_ZHYJDorJDHZ) + y_II * np.sin(
                    alpha_ZHYJDorJDHZ)
                Y_middlePilePoint = Y_ZHorHZ + x_II * np.sin(alpha_ZHYJDorJDHZ) - y_II * np.cos(
                    alpha_ZHYJDorJDHZ)
            else:
                self.sendTopInfo("W", "中桩点不在曲线上！")
                return None
            self.textEdit.append("计算完成！坐标为: X:{}m,Y:{}m".format(X_middlePilePoint, Y_middlePilePoint))
        else:
            self.sendTopInfo("W", "主点里程计算检核错误！")
            return None
